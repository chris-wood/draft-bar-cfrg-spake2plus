<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.1.2 -->
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-bar-cfrg-spake2plus-latest" category="info" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 2.39.0 -->
  <front>
    <title abbrev="spake2plus">SPAKE2+, an Augmented PAKE</title>
    <seriesInfo name="Internet-Draft" value="draft-bar-cfrg-spake2plus-latest"/>
    <author initials="T." surname="Taubert" fullname="Tim Taubert">
      <organization>Apple Inc.</organization>
      <address>
        <postal>
          <street>One Apple Park Way</street>
          <city>Cupertino, California 95014</city>
          <country>United States of America</country>
        </postal>
        <email>ttaubert@apple.com</email>
      </address>
    </author>
    <author initials="C.A." surname="Wood" fullname="Christopher A. Wood">
      <organization/>
      <address>
        <email>caw@heapingbits.net</email>
      </address>
    </author>
    <date year="2020" month="March" day="20"/>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This document describes SPAKE2+, a Password Authenticated Key Exchange (PAKE) protocol
run between two parties for deriving a strong shared key with no risk of disclosing the password.
SPAKE2+ is an augmented PAKE protocol, as only one party has knowledge of the password.
This method is simple to implement, compatible with any prime order group and is computationally efficient.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>This document describes SPAKE2+, a Password Authenticated Key Exchange (PAKE) protocol
run between two parties for deriving a strong shared key with no risk of disclosing the password.
SPAKE2+ is an augmented PAKE protocol, as only one party makes direct use of the password during the execution of the protocol.
The other party only needs a verification value at the time of the protocol execution instead of the password.
The verification value can be computed once, during an offline initialization phase.
The party using the password directly would typically be a client, and acts as a prover,
while the other party would be a server, and acts as verifier.</t>
      <t>The protocol is augmented in the sense that it provides some resilience to the compromise or extraction of the verification value.
The design of the protocol forces the adversary to recover the password from the verification value to successful execute the protocol.
Hence this protocol can be advantageously combined with a salted Password Hashing Function to increase the cost of the recovery and slow down attacks.
The verification value cannot be used directly to successfully run the protocol as a prover,
making this protocol more robust than balanced PAKEs which don't benefit from Password Hashing Functions to the same extend.</t>
      <t>This augmented property is especially valuable in scenarios where the execution of the protocol is constrained
and the adversary can not query the salt of the password hash function ahead of the attack.
Constraints may consist in being in physical proximity through a local network or
when initiation of the protocol requires a first authentication factor.</t>
      <t>This password-based key exchange protocol is compatible with any group.
It only relies on group operations making it simple and computationally efficient. It also has a security proof.
Predetermined parameters for a selection of commonly used groups are also provided.</t>
      <t>This document has content split out from a related document specifying SPAKE2 <xref target="I-D.irtf-cfrg-spake2" format="default"/>.</t>
    </section>
    <section anchor="requirements-notation" numbered="true" toc="default">
      <name>Requirements Notation</name>
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119" format="default"/>.</t>
    </section>
    <section anchor="definition-of-spake2" numbered="true" toc="default">
      <name>Definition of SPAKE2+</name>
      <section anchor="setup" numbered="true" toc="default">
        <name>Offline Initialization</name>
        <t>Let G be a group in which the computational Diffie-Hellman (CDH)
problem is hard. Suppose G has order p*h where p is a large prime;
h will be called the cofactor. Let I be the unit element in
G, e.g., the point at infinity if G is an elliptic curve group. We denote the
operations in the group additively. We assume there is a representation of
elements of G as byte strings: common choices would be SEC1
uncompressed or compressed <xref target="SEC1" format="default"/> for elliptic curve groups or big
endian integers of a fixed (per-group) length for prime field DH.
We fix two elements M and N in the prime-order subgroup of G as defined
in the table in this document for common groups, as well as a generator P
of the (large) prime-order subgroup of G. P is specified in the document defining
the group, and so we do not repeat it here.</t>
        <t>|| denotes concatenation of strings. We also let len(S) denote the
length of a string in bytes, represented as an eight-byte little-
endian number. Finally, let nil represent an empty string, i.e.,
len(nil) = 0.</t>
        <t>KDF is a key-derivation function that takes as input a salt, intermediate
keying material (IKM), info string, and derived key length L to derive a
cryptographic key of length L.
MAC is a Message Authentication Code algorithm that takes a secret key and
message as input to produce an output.
Let Hash be a hash function from arbitrary strings to bit strings of a fixed length. Common choices
for Hash are SHA256 or SHA512 <xref target="RFC6234" format="default"/>.
Let PBKDF be a Password-Based Key Derivation Function designed to slow down brute-force attackers.
Brute-force resistance may be obtained through various computation hardness parameters such as memory or CPU cycles,
and are typically configurable.
Scrypt <xref target="RFC7914" format="default"/> and Argon2 are common examples of PBKDF functions.
PBKDF and hardness parameters selection for the PBKDF are out of scope of this document.
<xref target="Ciphersuites" format="default"/> specifies variants of KDF, MAC, and Hash
suitable for use with the protocols contained herein.</t>
        <t>Let A and B be two parties. A and B may also have digital
representations of the parties' identities such as Media Access Control addresses
or other names (hostnames, usernames, etc). A and B may share Additional
Authenticated Data (AAD) of length at most 2^16 - 1 bits that is separate
from their identities which they may want to include in the protocol execution.
One example of AAD is a list of supported protocol versions if SPAKE2+ were
used in a higher-level protocol which negotiates the use of a particular PAKE. Including
this list would ensure that both parties agree upon the same set of supported protocols
and therefore prevent downgrade attacks.</t>
      </section>
      <section anchor="flow" numbered="true" toc="default">
        <name>Protocol Flow</name>
        <t>SPAKE2+ is a two round protocol that establishes a shared secret with an
additional round for key confirmation. Prior to invocation, A and B are provisioned with
information such as the input password needed to run the protocol.
A preamble exchange may occur in order to communicate identities, protocol version and PBKDF parameters related to the verification value.
Details of the preamble phase is out of scope of this document.
During the first round, A, the prover, sends a public share pA
to B, the verifier, and B responds with its own public share pB. Both A and B then derive a shared secret
used to produce encryption and authentication keys. The latter are used during the second
round for key confirmation. (<xref target="keys" format="default"/> details the key derivation and
confirmation steps.) In particular, B sends a key confirmation message cB to A, and A responds
with its own key confirmation message cA. (Note that pB and cB MAY be sent in the same message.)
Both parties MUST NOT consider the protocol complete prior to receipt and validation of these key
confirmation messages.</t>
        <t>This sample trace is shown below.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
               A                           B

               |         (Preamble)        |
               |<- - - - - - - - - - - - ->|
               |                           |
               |       (setup protocol)    |
  (compute pA) |             pA            |
               |-------------------------->|
               |             pB            | (compute pB)
               |<--------------------------|
               |                           |
               |       (derive secrets)    | (compute cB)
               |             cB            |
               |<--------------------------|
  (compute cA) |             cA            |
               |-------------------------->|

]]></artwork>
      </section>
      <section anchor="spake2plus" numbered="true" toc="default">
        <name>SPAKE2+</name>
        <t>This protocol appears in <xref target="TDH" format="default"/>. Let w0
and w1 be two integers derived by hashing the password pw with the identities
of the two participants, A and B. Specifically,
w0s || w1s = PBKDF(len(pw) || pw || len(A) || A || len(B) || B),
and then computing w0 = w0s mod p and w1 = w1s mod p.
If both identities A and B are absent, then w0s || w1s = PBKDF(pw), i.e.,
the length prefix is omitted as in <xref target="setup" format="default"/>.
The party B stores the verification value pair L=w1*P and w0.</t>
        <t>Note that standards such as NIST.SP.800-56Ar3 suggest taking mod p of a
hash value that is 64 bits longer than that needed to represent p to remove
statistical bias introduced by the modulation. Protocols using this specification must define
the method used to compute w0 and w1: it may be necessary to carry out various
forms of normalization of the password before hashing <xref target="RFC8265" format="default"/>.
The hashing algorithm SHOULD be a PBKDF so as to slow down brute-force
attackers.</t>
        <t>When executing SPAKE2+, A selects x uniformly at random from the
numbers in the range [0, p), and lets X=x*P+w0*M, then transmits pA=X to
B. Upon receipt of X, A computes h*X and aborts if the result is equal
to I. B then selects y uniformly at random from the numbers in [0, p),
then computes Y=y*P+w0*N, and transmits pB=Y to A.</t>
        <t>A computes Z as h*x*(Y-w0*N), and V as h*w1*(Y-w0*N). B computes Z as h*y*(X-
w0*M) and V as h*y*L. Both share Z and V as common values. It is essential
that both Z and V be used in combination with the transcript to
derive the keying material. The protocol transcript encoding is shown below.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
TT = len(A) || A || len(B) || B || len(X) || X
  || len(Y) || Y || len(Z) || Z || len(V) || V
  || len(w0) || w0
]]></artwork>
        <t>If an identity is absent, it is omitted from the transcript entirely. For example,
if both A and B are absent, then TT = len(X) || X || len(Y) || Y || len(Z) || Z || len(w0) || w0.
Likewise, if only A is absent, TT = len(B) || B || len(X) || X || len(Y) || Y || len(Z) || Z || len(w0) || w0.
This must only be done for applications in which identities are implicit. Otherwise,
the protocol risks Unknown Key Share attacks (discussion of Unknown Key Share attacks
in a specific protocol is given in <xref target="I-D.ietf-mmusic-sdp-uks" format="default"/>.</t>
        <t>Upon completion of this protocol, A and B compute shared secrets Ke, KcA, and KcB as
specified in <xref target="keys" format="default"/>. B MUST send A a key confirmation message Fb
so both parties agree upon these shared secrets. This confirmation message Fb
is computed as a MAC over the received share (pA) using KcB. Specifically, B
computes Fb = MAC(KcB, pA). After receipt and verification of B's confirmation
message, A MUST send B a confirmation message using a MAC computed equivalently
except with the use of pB and KcA. Key confirmation verification requires computing
F and checking for equality against that which was received.</t>
      </section>
    </section>
    <section anchor="keys" numbered="true" toc="default">
      <name>Key Schedule and Key Confirmation</name>
      <t>The protocol transcript TT, as defined in <xref target="spake2plus" format="default"/>,
is unique and secret to A and B. Both parties use TT to
derive shared symmetric secrets Ke and Ka as Ke || Ka = Hash(TT). The length of each
key is equal to half of the digest output, e.g., |Ke| = |Ka| = 128 bits for SHA-256.</t>
      <t>Both endpoints use Ka to derive subsequent MAC keys for key confirmation messages.
Specifically, let KcA and KcB be the MAC keys used by A and B, respectively.
A and B compute them as KcA || KcB = KDF(nil, Ka, "ConfirmationKeys" || AAD), where AAD
is the associated data each given to each endpoint, or nil (empty string)
if none was provided.
AAD may also include a string identifying the protocol, ciphersuite and all its parameters,
including the definition of the group, and the element M and N. It may be omitted.</t>
      <t>The length of each of KcA and KcB is equal to half of the KDF
output, e.g., |KcA| = |KcB| = 128 bits for HKDF with SHA256.</t>
      <t>The resulting key schedule for this protocol, given transcript TT and additional associated data AAD, is as follows.</t>
      <artwork name="" type="" align="left" alt=""><![CDATA[
TT  -> Hash(TT) = Ka || Ke
AAD -> KDF(nil, Ka, "ConfirmationKeys" || AAD) = KcA || KcB
]]></artwork>
      <t>A and B output Ke as the shared secret from the protocol. Ka and its derived keys (KcA and KcB)
are not used for anything except key confirmation.</t>
    </section>
    <section anchor="Ciphersuites" numbered="true" toc="default">
      <name>Ciphersuites</name>
      <t>This section documents SPAKE2+ ciphersuite configurations. A ciphersuite
indicates a group, cryptographic hash algorithm, and pair of KDF and MAC functions, e.g.,
SPAKE2+-P256-SHA256-HKDF-HMAC. This ciphersuite indicates a SPAKE2+ protocol instance over
P-256 that uses SHA256 along with HKDF <xref target="RFC5869" format="default"/> and HMAC <xref target="RFC2104" format="default"/>
for G, Hash, KDF, and MAC functions, respectively.</t>
      <t>The following points represent permissible point generation seeds
for the groups listed in the Table <xref target="spake2_ciphersuites" format="default"/>,
using the algorithm presented in <xref target="pointgen" format="default"/>.
These bytestrings are compressed points as in <xref target="SEC1" format="default"/>
for curves from <xref target="SEC1" format="default"/>.</t>
      <t>For P256:
~~~
M =
02886e2f97ace46e55ba9dd7242579f2993b64e16ef3dcab95afd497333d8fa12f
seed: 1.2.840.10045.3.1.7 point generation seed (M)</t>
      <t>N =
03d8bbd6c639c62937b04d997f38c3770719c629d7014d49a24b4f98baa1292b49
seed: 1.2.840.10045.3.1.7 point generation seed (N)
~~~</t>
      <t>For P384:
~~~
M =
030ff0895ae5ebf6187080a82d82b42e2765e3b2f8749c7e05eba366434b363d3dc
36f15314739074d2eb8613fceec2853
seed: 1.3.132.0.34 point generation seed (M)</t>
      <t>N =
02c72cf2e390853a1c1c4ad816a62fd15824f56078918f43f922ca21518f9c543bb
252c5490214cf9aa3f0baab4b665c10
seed: 1.3.132.0.34 point generation seed (N)
~~~</t>
      <t>For P521:
~~~
M =
02003f06f38131b2ba2600791e82488e8d20ab889af753a41806c5db18d37d85608
cfae06b82e4a72cd744c719193562a653ea1f119eef9356907edc9b56979962d7aa
seed: 1.3.132.0.35 point generation seed (M)</t>
      <t>N =
0200c7924b9ec017f3094562894336a53c50167ba8c5963876880542bc669e494b25
32d76c5b53dfb349fdf69154b9e0048c58a42e8ed04cef052a3bc349d95575cd25
seed: 1.3.132.0.35 point generation seed (N)
~~~</t>
      <t>For edwards25519:
~~~
M =
d048032c6ea0b6d697ddc2e86bda85a33adac920f1bf18e1b0c6d166a5cecdaf
seed: edwards25519 point generation seed (M)</t>
      <t>N =
d3bfb518f44f3430f29d0c92af503865a1ed3281dc69b35dd868ba85f886c4ab
seed: edwards25519 point generation seed (N)
~~~</t>
      <t>For edwards448:
~~~
M =
b6221038a775ecd007a4e4dde39fd76ae91d3cf0cc92be8f0c2fa6d6b66f9a12
942f5a92646109152292464f3e63d354701c7848d9fc3b8880
seed: edwards448 point generation seed (M)</t>
      <t>N =
6034c65b66e4cd7a49b0edec3e3c9ccc4588afd8cf324e29f0a84a072531c4db
f97ff9af195ed714a689251f08f8e06e2d1f24a0ffc0146600
seed: edwards448 point generation seed (N)
~~~</t>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>No IANA action is required.</t>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>SPAKE2+ appears in <xref target="TDH" format="default"/> along with a path to a proof that
server compromise does not lead to password compromise under the DH assumption
(though the corresponding model excludes pre-computation attacks).</t>
      <t>Elements received from a peer MUST be checked for group membership:
failure to properly validate group elements can lead to attacks. Beyond the cofactor
multiplication checks to ensure that these elements are in the prime order subgroup
of G, it is essential that endpoints verify received points are members of G.</t>
      <t>The choices of random numbers MUST BE uniform. Randomly generated values (e.g., x and y)
MUST NOT be reused; such reuse may permit dictionary attacks on the password.</t>
    </section>
    <section anchor="acknowledgements" numbered="true" toc="default">
      <name>Acknowledgements</name>
      <t>Thanks to Ben Kaduk and Watson Ladd, from which this specification originally emanated.</t>
    </section>
    <section anchor="pointgen" numbered="true" toc="default">
      <name>Algorithm used for Point Generation</name>
      <t>This section describes the algorithm that was used to generate
the points (M) and (N) in the table in <xref target="Ciphersuites" format="default"/>.</t>
      <t>For each curve in the table below, we construct a string
using the curve OID from <xref target="RFC5480" format="default"/> (as an ASCII
string) or its name,
combined with the needed constant, for instance "1.3.132.0.35
point generation seed (M)" for P-512.  This string is turned
into a series of blocks by hashing with SHA256, and hashing that
output again to generate the next 32 bytes, and so on.  This
pattern is repeated for each group and value, with the string
modified appropriately.</t>
      <t>A byte string of length equal to that of an encoded group
element is constructed by concatenating as many blocks as are
required, starting from the first block, and truncating to the
desired length.  The byte string is then formatted as required
for the group.  In the case of Weierstrass curves, we take the
desired length as the length for representing a compressed point
(section 2.3.4 of <xref target="SEC1" format="default"/>),
and use the low-order bit of the first byte as the sign bit.
In order to obtain the correct format, the value of the first
byte is set to 0x02 or 0x03 (clearing the first six bits
and setting the seventh bit), leaving the sign bit as it was
in the byte string constructed by concatenating hash blocks.
For the <xref target="RFC8032" format="default"/> curves a different procedure is used.
For edwards448 the 57-byte input has the least-significant 7 bits of the
last byte set to zero, and for edwards25519 the 32-byte input is
not modified.  For both the <xref target="RFC8032" format="default"/> curves the
(modified) input is then interpreted
as the representation of the group element.
If this interpretation yields a valid group element with the
correct order (p), the (modified) byte string is the output.  Otherwise,
the initial hash block is discarded and a new byte string constructed
from the remaining hash blocks. The procedure of constructing a
byte string of the appropriate length, formatting it as
required for the curve, and checking if it is a valid point of the correct
order, is repeated
until a valid element is found.</t>
      <t>The following python snippet generates the above points,
assuming an elliptic curve implementation following the
interface of Edwards25519Point.stdbase() and
Edwards448Point.stdbase() in Appendix A of <xref target="RFC8032" format="default"/>:</t>
      <artwork name="" type="" align="left" alt=""><![CDATA[
def iterated_hash(seed, n):
    h = seed
    for i in range(n):
        h = hashlib.sha256(h).digest()
    return h

def bighash(seed, start, sz):
    n = -(-sz // 32)
    hashes = [iterated_hash(seed, i) for i in range(start, start + n)]
    return b''.join(hashes)[:sz]

def canon_pointstr(ecname, s):
    if ecname == 'edwards25519':
        return s
    elif ecname == 'edwards448':
        return s[:-1] + bytes([s[-1] & 0x80])
    else:
        return bytes([(s[0] & 1) | 2]) + s[1:]

def gen_point(seed, ecname, ec):
    for i in range(1, 1000):
        hval = bighash(seed, i, len(ec.encode()))
        pointstr = canon_pointstr(ecname, hval)
        try:
            p = ec.decode(pointstr)
            if p != ec.zero_elem() and p * p.l() == ec.zero_elem():
                return pointstr, i
        except Exception:
            pass
]]></artwork>
    </section>
    <section anchor="testvectors" numbered="true" toc="default">
      <name>Test Vectors</name>
      <t>This section contains test vectors for SPAKE2+ using
the P256-SHA256-HKDF-HMAC ciphersuite. (Choice of PBKDF is omitted
and values for w and w0,w1 are provided directly.) All points are
encoded using the uncompressed format, i.e., with a 0x04 octet
prefix, specified in <xref target="SEC1" format="default"/> A and B identity strings
are provided in the protocol invocation.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <seriesInfo name="DOI" value="10.17487/RFC2119"/>
            <seriesInfo name="RFC" value="2119"/>
            <seriesInfo name="BCP" value="14"/>
            <author initials="S." surname="Bradner" fullname="S. Bradner">
              <organization/>
            </author>
            <date year="1997" month="March"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="TDH">
          <front>
            <title>The Twin-Diffie Hellman Problem and Applications</title>
            <seriesInfo name="EUROCRYPT 2008.  Volume 4965 of Lecture notes in Computer Science, pages 127-145.  Springer-Verlag, Berlin, Germany." value=""/>
            <author>
              <organization/>
            </author>
            <date year="2008"/>
          </front>
        </reference>
        <reference anchor="I-D.irtf-cfrg-spake2" target="http://www.ietf.org/internet-drafts/draft-irtf-cfrg-spake2-10.txt">
          <front>
            <title>SPAKE2, a PAKE</title>
            <seriesInfo name="Internet-Draft" value="draft-irtf-cfrg-spake2-10"/>
            <author initials="W" surname="Ladd" fullname="Watson Ladd">
              <organization/>
            </author>
            <author initials="B" surname="Kaduk" fullname="Benjamin Kaduk">
              <organization/>
            </author>
            <date month="February" day="18" year="2020"/>
            <abstract>
              <t>This document describes SPAKE2 which is a protocol for two parties that share a password to derive a strong shared key with no risk of disclosing the password.  This method is compatible with any group, is computationally efficient, and SPAKE2 has a security proof.</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC6234" target="https://www.rfc-editor.org/info/rfc6234">
          <front>
            <title>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)</title>
            <seriesInfo name="DOI" value="10.17487/RFC6234"/>
            <seriesInfo name="RFC" value="6234"/>
            <author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd">
              <organization/>
            </author>
            <author initials="T." surname="Hansen" fullname="T. Hansen">
              <organization/>
            </author>
            <date year="2011" month="May"/>
            <abstract>
              <t>Federal Information Processing Standard, FIPS</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC7914" target="https://www.rfc-editor.org/info/rfc7914">
          <front>
            <title>The scrypt Password-Based Key Derivation Function</title>
            <seriesInfo name="DOI" value="10.17487/RFC7914"/>
            <seriesInfo name="RFC" value="7914"/>
            <author initials="C." surname="Percival" fullname="C. Percival">
              <organization/>
            </author>
            <author initials="S." surname="Josefsson" fullname="S. Josefsson">
              <organization/>
            </author>
            <date year="2016" month="August"/>
            <abstract>
              <t>This document specifies the password-based key derivation function scrypt.  The function derives one or more secret keys from a secret string.  It is based on memory-hard functions, which offer added protection against attacks using custom hardware.  The document also provides an ASN.1 schema.</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC8265" target="https://www.rfc-editor.org/info/rfc8265">
          <front>
            <title>Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords</title>
            <seriesInfo name="DOI" value="10.17487/RFC8265"/>
            <seriesInfo name="RFC" value="8265"/>
            <author initials="P." surname="Saint-Andre" fullname="P. Saint-Andre">
              <organization/>
            </author>
            <author initials="A." surname="Melnikov" fullname="A. Melnikov">
              <organization/>
            </author>
            <date year="2017" month="October"/>
            <abstract>
              <t>This document describes updated methods for handling Unicode strings representing usernames and passwords.  The previous approach was known as SASLprep (RFC 4013) and was based on Stringprep (RFC 3454). The methods specified in this document provide a more sustainable approach to the handling of internationalized usernames and passwords.  This document obsoletes RFC 7613.</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC5869" target="https://www.rfc-editor.org/info/rfc5869">
          <front>
            <title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
            <seriesInfo name="DOI" value="10.17487/RFC5869"/>
            <seriesInfo name="RFC" value="5869"/>
            <author initials="H." surname="Krawczyk" fullname="H. Krawczyk">
              <organization/>
            </author>
            <author initials="P." surname="Eronen" fullname="P. Eronen">
              <organization/>
            </author>
            <date year="2010" month="May"/>
            <abstract>
              <t>This document specifies a simple Hashed Message Authentication Code (HMAC)-based key derivation function (HKDF), which can be used as a building block in various protocols and applications.  The key derivation function (KDF) is intended to support a wide range of applications and requirements, and is conservative in its use of cryptographic hash functions.  This document is not an Internet  Standards Track specification; it is published for informational  purposes.</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC2104" target="https://www.rfc-editor.org/info/rfc2104">
          <front>
            <title>HMAC: Keyed-Hashing for Message Authentication</title>
            <seriesInfo name="DOI" value="10.17487/RFC2104"/>
            <seriesInfo name="RFC" value="2104"/>
            <author initials="H." surname="Krawczyk" fullname="H. Krawczyk">
              <organization/>
            </author>
            <author initials="M." surname="Bellare" fullname="M. Bellare">
              <organization/>
            </author>
            <author initials="R." surname="Canetti" fullname="R. Canetti">
              <organization/>
            </author>
            <date year="1997" month="February"/>
            <abstract>
              <t>This document describes HMAC, a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative cryptographic hash function, e.g., MD5, SHA-1, in combination with a secret shared key.  The cryptographic strength of HMAC depends on the properties of the underlying hash function.  This memo provides information for the Internet community.  This memo does not specify an Internet standard of any kind</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC5480" target="https://www.rfc-editor.org/info/rfc5480">
          <front>
            <title>Elliptic Curve Cryptography Subject Public Key Information</title>
            <seriesInfo name="DOI" value="10.17487/RFC5480"/>
            <seriesInfo name="RFC" value="5480"/>
            <author initials="S." surname="Turner" fullname="S. Turner">
              <organization/>
            </author>
            <author initials="D." surname="Brown" fullname="D. Brown">
              <organization/>
            </author>
            <author initials="K." surname="Yiu" fullname="K. Yiu">
              <organization/>
            </author>
            <author initials="R." surname="Housley" fullname="R. Housley">
              <organization/>
            </author>
            <author initials="T." surname="Polk" fullname="T. Polk">
              <organization/>
            </author>
            <date year="2009" month="March"/>
            <abstract>
              <t>This document specifies the syntax and semantics for the Subject Public Key Information field in certificates that support Elliptic Curve Cryptography.  This document updates Sections 2.3.5 and 5, and the ASN.1 module of "Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile", RFC 3279.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
        </reference>
        <reference anchor="RFC8032" target="https://www.rfc-editor.org/info/rfc8032">
          <front>
            <title>Edwards-Curve Digital Signature Algorithm (EdDSA)</title>
            <seriesInfo name="DOI" value="10.17487/RFC8032"/>
            <seriesInfo name="RFC" value="8032"/>
            <author initials="S." surname="Josefsson" fullname="S. Josefsson">
              <organization/>
            </author>
            <author initials="I." surname="Liusvaara" fullname="I. Liusvaara">
              <organization/>
            </author>
            <date year="2017" month="January"/>
            <abstract>
              <t>This document describes elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA).  The algorithm is instantiated with recommended parameters for the edwards25519 and edwards448 curves.  An example implementation and test vectors are provided.</t>
            </abstract>
          </front>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="I-D.ietf-mmusic-sdp-uks" target="http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sdp-uks-07.txt">
          <front>
            <title>Unknown Key Share Attacks on uses of TLS with the Session Description Protocol (SDP)</title>
            <seriesInfo name="Internet-Draft" value="draft-ietf-mmusic-sdp-uks-07"/>
            <author initials="M" surname="Thomson" fullname="Martin Thomson">
              <organization/>
            </author>
            <author initials="E" surname="Rescorla" fullname="Eric Rescorla">
              <organization/>
            </author>
            <date month="August" day="9" year="2019"/>
            <abstract>
              <t>This document describes unknown key-share attacks on the use of Datagram Transport Layer Security for the Secure Real-Time Transport Protocol (DTLS-SRTP).  Similar attacks are described on the use of DTLS-SRTP with the identity bindings used in Web Real-Time Communications (WebRTC) and SIP identity.  These attacks are difficult to mount, but they cause a victim to be mislead about the identity of a communicating peer.  Mitigation techniques are defined that implementations of RFC 8122 are encouraged to deploy.</t>
            </abstract>
          </front>
        </reference>
      </references>
    </references>
  </back>
  <!-- ##markdown-source:
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
XpsV60VqiRE6gxnaDKZ3dv6k7+xMHgNmIqSJEbnvd7sc5vUx81THcbuv18ZO
7Ni3iQ1F3DrU+5uDe+lmw04dcqlic7TRG0EgXtBd+noPRITS8SNgdR4PhHJX
7kCrZJ4SDekGEwQGLAEcOl5SNnGIOHHQuiR+IJdHqRNt4LQ0yHhdE4HGcUq5
3ubAK6DClIFVjBHjUyiwCh66sibCMTBymvqYOBgecAhME4QWKY5WExGt85Qc
ax0nUL7jwMCR+4broPimEK0ryDk98vkz695tOBHNRZiuHJj2VGYsSCtSVgBC
FuojdukBzyE/3Rcbla1gX2g7HXqDx4Dl/Inr/EAXHzmardF5zjL8wtKHlww1
l8t9aAyRQTkmuYS9N89W1nlUHdVPNIZba8dKDmGvgZt2kSt4NnAFT106xvb2
WH76d5/uiktOOthOpE0Q1Qr7SUKylVMzWSsnbNQ1PcbeCFxVOtwiTkPVfv/d
SAsbK0oKstonGNZqASFbt4Hcgri91/22iBlyMzP0EnZNEA7gXYuRVnqS2nS1
roYsOzCKyICHlq/ZfhtSCvsoZWs+4POydNNswuu3O6iBPmggUle5AwKhhwf7
4oHwgNTT80daiGEKh5ypGL9VB00Uc1acQ0hSDJgEE2sNtJnaKkBUKSpBET5b
fC5gbUTv4unz/oALVjUIRGQ+xDg/Q49nZPb090I6UZOvQ7jpMdDLPuk6z5dn
GuLnUAoEg+00jQA+y2PiwSqHE1tvO/CTb4NR5T0BirM1O9SIVeykkC0qTib2
Fb502UxSLKUtZTcM0U6qCFOEHYWlNQdaIflfc9nSPo2IS4Walg1wSA/4DHIC
cDHBZEqqjE8Tnx0cjP40GI3J6BM8l6fEOQbIxnvDUw4qKE89bxhZR786uCcD
m7cC3LBACD7kCN9EUbAWrnPa+pryCyoj4iPFVDgzDyuO5erA6QNFg/tOls4O
IQOB2yEDYuI1UXurEN0eCMGzyzciOkQbKABHhuwD69QLepakq31BtgMpMEuG
IcZs4YMYuoJWrPIs4KXGlKiPkgIfJrymlGUYcNNf0MJbQazjGWIJGQjzPHan
qISUPYKr0JFgy5S5zqdPZymVEct9CoUGcNYClUwgaRwCdhsISLFWB2K6QyvY
PtKZlKNz1NcONHWApKlO9ijNXO2/l7zLKbvIpvDg1t8Ty0x0B+2K0xVO2jhd
l1U2sTav/kogTINGcQnD8uw56blYclID6aWyyoZ8I/um0gHgOvelqmopemsk
V/xxQAgV5qOqon4XNq6FiCX7WAo0nG7V5VxWUvSWy/N+ywpAo7eUuwX/5U/F
UPika6XJjomDxE5YJJuKpkUbnzrAOfD512CLyQw3+1g1ru24VuE6VMc2ksX1
5+W5iWdSnUeWFPwUJofSqynF0RFFHZrBxRTK4QAZZ8GewMjDIW8UIoxmoYYy
U6ucMg+TfZvqjdR8ivZwhJwMulRzB/TapQEmhkiHFSor94UpHYTgUF2akqtC
YctdnjU5IQLD2xEpbdpWqITyUkjPB/aksCGw1LFqMmWKPC8tGo/I0Hy6n+AX
4s12DYulFdYja1GLgVQlqUJarrXF1qUyY7hNMuTIWlzMFqQ3ZNXZYHBtHgwD
GCnpMDH3Q67dw6AWPsloICMhBpkqgkPeyiyvBZ+oo91DnYpS3Utb0uPE3nWW
RBy5JW2uczsStDxCnEYs1xEL1pKxQkhLgt4S0MEN6WGAtRVqGSqbF5mc/raa
zrmCxdg02m3h4nIYceEPDNp5UxnUyS0TGyQcWJy5qAU7wlXA3R58i4xG75YO
IDsdtICzBbBTcimQOyxihpLyki/qrj91xSnJq+UXWYU6SOjKhdamlvNWGbsK
S7ujnByCAgNJ+R8oSL0SOk/XbxqEsTMgdL4kXr1Pn2grGPrYELoyOWUrkKI4
o70MMYHalW4fKttS4wEQtGQ8PkjYMCU6JRyXmojLmohOh4h3r14C4hc6EoWa
7U51WeAUrugteY9SJ1WNMTAL3b5z2rYbNkHWxZXY1v/qWl1O9rHi5EArX6Ei
hUSFj4NgpnG7klIywZzbIC5tnaDUJpeqmCy15ZojFwWjgkf+9a9/dZpI+FmK
u39OneOnf68/9S6NhvTrezce/vtQ3PHvu5sPfwGOOx/ucXZeE7RvH+6Zojc0
q3+0866D8M2dh3f+/BHMkJLOvQaI0/4tpLnz5/+INEb9tdaX/SOYoltg6lxF
XWz+KgLNQTc4EP1vOMAiTG7T+sdP95tBANuzairHO+SlRalLQf9xdf4EKQGX
Sa49dtLXvo0F6+Tfplwh9+3WN1ofu+sm4Gwckc2367AySncUw9Yu1BWvdYDL
wfrAufZKgST52i+RXLK/6lG2ubvu09c4BP/TF0u+XtrLU7487Q9sjJGZPILg
vPawF228zQGnMAg+4EP4K9e5SHRg04rx2j5ehiV3bnjjW0AEeDY3JmxNiAlf
SdUP8pFbpN46JWeS6+LZ53Y3Cba7ygsTpN3SJdhJhKDPHlz7//z6UqNAqXdj
i8u6c21jjhcXr6/c15fu3POGk+myGOHOCiaRU1lOs5kcFAw6nJCaBosJgadj
HRJvcur06/YB32sFLnWhYKcvt3DmNC5SIXbk+niYMsq6faqlh/DDyfBYNsCy
2YltqDV1F0OBLfUvdC2I6WuawtZjW5UCnzVvT6jiYvLMTFGyYbpNkSwoZUTE
YrJNypm3HNzwOEZd3zzuG4Q6ZLWSr9PHeTCdWCbaO03RwBRzdXrNgRcSKFne
mTo7rdTZ+YEEzaQNdY36G9IanVuW4iNVMgl6pLhgSgHMkanYdMXRxZ26Cllw
CPnOQ2DY174f/rUUPz74CHH65tr759fPjXTDQ2bllhi/Wz74EdA60NE3FOFb
Hwza/EiQGLKXYv3Pr3/UMVKIiJ/zFN0OK/cbFiX16x5JGRC/cG0QZtE4fBEN
0ULDAO+0lBtnv31wsBi80Ii1EDh98JajHRC0Be5PxAXADNR7b4e80tDke3OH
lKy+RSDfWItDez8OHSZcv7MWd56ZqFMHoT81t01lgfWs5J4J98dIg1IiUJ1f
2TW2J5hmplOppbM2tIxrVBBXwCjj2UwA2S6k6Ui1yZGaZYhy85hriLfFRFdX
MHF3m1t7+SNf/giPZb54y1+8tZc/8eVP9vJ7vvy+efza42/gfNiLwRhT2Vmb
Yu4hWvubVm1rWktJB58qLbjM/ojb1hz2DZzU2Pc7jXqNqcHlz2FSA+46z9L3
6jot1YDEn/tXyzbk9f63k+4vH6eHY8gu8lkhlZwzXfuRrWGwphvT8myEPDX1
4IwrV7ykjJwhd7pdybR8X4o3GU3oZFwRfM3ybJJ0BFJpGe3L0pjLOx90uEJh
DXqnRbmCuGYmCOHmm6qSIfLZMo2GZbwb7t+X3KBi82OSgto6t+KZJiG3rqCT
2pUAaiCeRibreYoQTpZOp7RvszBSdk5OKJGiXe/OhR6FDgz6F8oh5TEYpIW6
kX3rbvWEkqndU31P1MMRbH0pANNWpUcRvHaYwOcoikKCUlusRyEEDzv18NiA
4n5XLBNKWDspVTveAHVPv+qCaavcROiGPKc003IbMhoujUCNEnVQYfkghZuD
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

-->

</rfc>
